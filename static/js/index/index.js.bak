// HTML entity decoder function for Mermaid diagrams
function decodeHtmlEntities(text) {
  if (!text) return text;
  
  // Fixes for arrow syntax (most critical fix)
  text = text.replace(/--&gt;/g, '-->');
  
  // Common HTML entities
  const entities = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&nbsp;': ' '
  };
  
  // Replace all encoded entities with their decoded versions
  return text.replace(/&[a-z0-9#]+;/gi, entity => {
    if (entities[entity]) {
      return entities[entity];
    }
    
    // Handle numeric entities
    if (entity.startsWith('&#')) {
      try {
        const tempEl = document.createElement('span');
        tempEl.innerHTML = entity;
        return tempEl.innerText;
      } catch(e) {
        return entity;
      }
    }
    
    return entity;
  });
}

$(document).ready(function() {
  // DOM elements
  const messageInput = $('#message-input');
  const sendButton = $('#send-button');
  const messagesContainer = $('#messages-container');
  const characterCount = $('#character-count');
  const clearButton = $('#clear-button');
  const regenerateButton = $('#regenerate-button');
  const fileUpload = $('#file-upload');
  const filePreviewContainer = $('#file-preview-container');
  const mobileSidebarToggle = $('#mobile-sidebar-toggle');
  const closeSidebarBtn = $('#close-sidebar-btn');
  const sidebarBackdrop = $('#sidebar-backdrop');
  const mobileSidebar = $('#mobile-topics-sidebar');
  const newChatBtn = $('#new-chat-btn');
  const mobileNewChatBtn = $('#mobile-new-chat-btn');
  
  // System prompt elements
  const editSystemPromptBtn = $('#edit-system-prompt-btn');
  const systemPromptDisplay = $('#system-prompt-display');
  const systemPromptForm = $('#system-prompt-form');
  const systemPromptInput = $('#system-prompt-input');
  const cancelSystemPromptBtn = $('#cancel-system-prompt');
  const saveSystemPromptBtn = $('#save-system-prompt');
  
  // Mobile system prompt elements
  const mobileEditSystemPromptBtn = $('#mobile-edit-system-prompt-btn');
  const mobileSystemPromptDisplay = $('#mobile-system-prompt-display');
  const mobileSystemPromptForm = $('#mobile-system-prompt-form');
  const mobileSystemPromptInput = $('#mobile-system-prompt-input');
  const mobileCancelSystemPromptBtn = $('#mobile-cancel-system-prompt');
  const mobileSaveSystemPromptBtn = $('#mobile-save-system-prompt');
  
  // Add mermaid error styles
  addMermaidErrorStyles();
  
  // State variables
  let currentTopic = "Getting started with Wisdomizer";
  let lastUserMessage = "";
  let uploadedFile = null;
  let isAiResponding = false;
  let currentStreamController = null;
  let currentChatUUID = null;
  let currentTopicLoadingId = null;
  let systemPrompt = "You are a helpful AI assistant. Format your responses using Markdown for better readability. Use code blocks with language specification for code examples.";
  
  // Configure Marked.js for Markdown rendering
  configureMarkdown();
  
  // Initialize syntax highlighting if available
  try {
    if (typeof hljs !== 'undefined') {
      hljs.configure({
        ignoreUnescapedHTML: true
      });
      hljs.highlightAll();
    } else {
      console.warn('Highlight.js not loaded. Syntax highlighting is disabled.');
    }
    
    // Initialize mermaid if available
    if (typeof mermaid !== 'undefined') {
      mermaid.initialize({
        startOnLoad: true,
        theme: 'dark',
        securityLevel: 'loose',
        logLevel: 3, // Error level to reduce console noise
        fontFamily: 'Poppins, sans-serif',
        flowchart: {
          htmlLabels: true,
          curve: 'basis'
        },
        sequence: {
          diagramMarginX: 50,
          diagramMarginY: 10,
          actorMargin: 50
        }
      });
      
      // Force global render attempts on page load
      setTimeout(() => {
        try {
          console.log('Attempting global mermaid render...');
          mermaid.run();
          console.log('Initial mermaid.run() executed');
        } catch (err) {
          console.error('Error during initial mermaid run:', err);
        }
        
        // Try a second time in case the first attempt failed
        setTimeout(() => {
          try {
            mermaid.run();
            console.log('Secondary mermaid.run() executed');
          } catch (err) {
            console.error('Error during secondary mermaid run:', err);
          }
        }, 2000);
      }, 1000);
      
      // Set up a MutationObserver to detect when new messages are added
      const messagesObserver = new MutationObserver((mutations) => {
        // Check if any of the mutations involve adding nodes
        const hasDiagramsToProcess = mutations.some(mutation => {
          return mutation.type === 'childList' && mutation.addedNodes.length > 0;
        });
        
        if (hasDiagramsToProcess) {
          console.log('New content detected in messages container');
          // Wait a short time to let the DOM settle
          setTimeout(() => {
            processMermaidDiagrams();
            // Try again with direct rendering after a short delay
            setTimeout(() => {
              forceMermaidRendering();
            }, 200);
          }, 100);
        }
      });
      
      // Start observing the messages container
      messagesObserver.observe(messagesContainer[0], {
        childList: true,
        subtree: true
      });
      
      console.log('Mutation observer set up for messages container');
    } else {
      console.warn('Mermaid.js not loaded. Diagram rendering is disabled.');
    }
  } catch (e) {
    console.error('Error initializing libraries:', e);
  }
  
  // Character count updating
  messageInput.on('input', function() {
    const count = $(this).val().length;
    characterCount.text(`${count}/4000`);
    
    // Disable send button if no input or if over character limit
    if (count > 0 && count <= 4000) {
      sendButton.prop('disabled', false);
    } else {
      sendButton.prop('disabled', true);
    }
  });
  
  // Configure Markdown parser
  function configureMarkdown() {
    // Configure the Markdown renderer
    marked.setOptions({
      breaks: true,
      gfm: true,
      headerIds: false
    });

    // Create a custom renderer
    const renderer = new marked.Renderer();
    
    // Original code function to preserve
    const originalCodeRenderer = renderer.code;
    
    // Override the code renderer to handle mermaid diagrams
    renderer.code = function(code, language, escaped) {
      // For mermaid diagrams, create a div with the mermaid class
      if (language === 'mermaid') {
        console.log('Detected mermaid code block, creating diagram container');
        
        // Create a unique ID for this diagram
        const id = `mermaid-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
        
        // Store the original code in a data attribute for reliable retrieval
        return `<div class="mermaid" id="${id}" data-content="${encodeURIComponent(code)}">${code}</div>`;
      }
      
      // For all other code blocks, use the original renderer
      return originalCodeRenderer.call(this, code, language, escaped);
    };
    
    // Use the custom renderer
    marked.use({ renderer });
  }
  
  // System prompt handling - desktop
  editSystemPromptBtn.on('click', function() {
    systemPromptForm.removeClass('hidden');
    systemPromptDisplay.addClass('hidden');
    systemPromptInput.val(systemPrompt);
    systemPromptInput.focus();
  });
  
  cancelSystemPromptBtn.on('click', function() {
    systemPromptForm.addClass('hidden');
    systemPromptDisplay.removeClass('hidden');
  });
  
  saveSystemPromptBtn.on('click', function() {
    const newPrompt = systemPromptInput.val().trim();
    if (newPrompt) {
      systemPrompt = newPrompt;
      systemPromptDisplay.text(systemPrompt);
      mobileSystemPromptDisplay.text(systemPrompt);
      systemPromptForm.addClass('hidden');
      systemPromptDisplay.removeClass('hidden');
      localStorage.setItem('systemPrompt', systemPrompt);
      createNotification('System prompt updated', 'success');
    } else {
      createNotification('System prompt cannot be empty', 'error');
    }
  });
  
  // System prompt handling - mobile
  mobileEditSystemPromptBtn.on('click', function() {
    mobileSystemPromptForm.removeClass('hidden');
    mobileSystemPromptDisplay.addClass('hidden');
    mobileSystemPromptInput.val(systemPrompt);
    mobileSystemPromptInput.focus();
  });
  
  mobileCancelSystemPromptBtn.on('click', function() {
    mobileSystemPromptForm.addClass('hidden');
    mobileSystemPromptDisplay.removeClass('hidden');
  });
  
  mobileSaveSystemPromptBtn.on('click', function() {
    const newPrompt = mobileSystemPromptInput.val().trim();
    if (newPrompt) {
      systemPrompt = newPrompt;
      systemPromptDisplay.text(systemPrompt);
      mobileSystemPromptDisplay.text(systemPrompt);
      mobileSystemPromptForm.addClass('hidden');
      mobileSystemPromptDisplay.removeClass('hidden');
      localStorage.setItem('systemPrompt', systemPrompt);
      createNotification('System prompt updated', 'success');
    } else {
      createNotification('System prompt cannot be empty', 'error');
    }
  });
  
  // Load saved system prompt if available
  const savedSystemPrompt = localStorage.getItem('systemPrompt');
  if (savedSystemPrompt) {
    systemPrompt = savedSystemPrompt;
    systemPromptDisplay.text(systemPrompt);
    mobileSystemPromptDisplay.text(systemPrompt);
  }
  
  // Send message on button click or enter key
  sendButton.on('click', sendMessage);
  messageInput.on('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });
  
  // Clear chat
  clearButton.on('click', function() {
    // Confirm before clearing
    if (confirm('Are you sure you want to clear this chat?')) {
      messagesContainer.empty();
      // Add the welcome message back
      addWelcomeMessage();
    }
  });
  
  // Regenerate last AI response
  regenerateButton.on('click', function() {
    if (lastUserMessage) {
      // Find and remove the last AI message
      $('.chat-ai').last().remove();
      // Resend the last user message
      processUserMessage(lastUserMessage);
    } else {
      createNotification('Nothing to regenerate', 'warning');
    }
  });
  
  // File upload handling
  fileUpload.on('change', function(e) {
    const file = e.target.files[0];
    if (file) {
      uploadedFile = file;
      showFilePreview(file);
    }
  });
  
  // Mobile sidebar toggle
  mobileSidebarToggle.on('click', function() {
    mobileSidebar.addClass('show');
    sidebarBackdrop.addClass('show');
  });
  
  closeSidebarBtn.on('click', function() {
    mobileSidebar.removeClass('show');
    sidebarBackdrop.removeClass('show');
  });
  
  sidebarBackdrop.on('click', function() {
    mobileSidebar.removeClass('show');
    sidebarBackdrop.removeClass('show');
  });
  
  // New chat button
  newChatBtn.on('click', startNewChat);
  mobileNewChatBtn.on('click', startNewChat);
  
  // Topic management
  $(document).on('click', '.topic-item', function(e) {
    // Don't trigger if clicking on action buttons
    if ($(e.target).closest('.topic-actions').length) {
      return;
    }
    
    // Load the selected topic
    const topicName = $(this).find('.topic-name').text();
    const topicUUID = $(this).data('uuid');
    loadTopic(topicName, topicUUID);
    
    // Update UI
    $('.topic-item').removeClass('bg-gray-700/50').addClass('hover:bg-gray-700/30');
    $('.topic-item').removeClass('text-gray-100').addClass('text-gray-300');
    $(this).removeClass('hover:bg-gray-700/30').addClass('bg-gray-700/50');
    $(this).removeClass('text-gray-300').addClass('text-gray-100');
    
    // Close mobile sidebar if open
    mobileSidebar.removeClass('show');
    sidebarBackdrop.removeClass('show');
  });
  
  // Topic rename
  $(document).on('click', '.topic-rename', function(e) {
    e.stopPropagation();
    const topicItem = $(this).closest('.topic-item');
    const topicName = topicItem.find('.topic-name').text();
    const topicUUID = topicItem.data('uuid');
    
    const newName = prompt('Enter new topic name:', topicName);
    if (newName && newName !== topicName) {
      renameTopic(topicUUID, newName);
    }
  });
  
  // Topic delete
  $(document).on('click', '.topic-delete', function(e) {
    e.stopPropagation();
    const topicItem = $(this).closest('.topic-item');
    const topicName = topicItem.find('.topic-name').text();
    const topicUUID = topicItem.data('uuid');
    
    if (confirm(`Are you sure you want to delete "${topicName}"?`)) {
      deleteTopic(topicUUID);
    }
  });
  
  // Functions
  function sendMessage() {
    const message = messageInput.val().trim();
    if (message.length === 0) return;
    
    // Add user message to chat
    addUserMessage(message);
    
    // Process the message
    processUserMessage(message);
    
    // Clear input
    messageInput.val('');
    characterCount.text('0/4000');
    
    // Store last message for regeneration
    lastUserMessage = message;
    
    // Clear any uploaded file
    if (uploadedFile) {
      uploadedFile = null;
      filePreviewContainer.addClass('hidden');
    }
  }
  
  function addUserMessage(message) {
    const time = getCurrentTime();
    const messageHtml = `
      <div class="chat chat-end">
        <div class="chat-image">
          <div class="w-10 h-10 rounded-full bg-gradient-to-br from-blue-400 to-indigo-600 flex items-center justify-center p-0">
            <i class="fas fa-user text-white text-sm transform translate-y-[1px]"></i>
          </div>
        </div>
        <div class="chat-header opacity-70 text-xs">
          You <span class="message-time">${time}</span>
        </div>
        <div class="chat-bubble msg-user bg-blue-600/70 text-white shadow-md border border-blue-500/30 backdrop-blur-sm">
          <p>${formatMessage(message)}</p>
        </div>
        <div class="chat-footer opacity-70 text-xs">
          Seen
        </div>
      </div>
    `;
    
    messagesContainer.append(messageHtml);
    applyHighlighting();
    scrollToBottom();
  }
  
  function addAiMessage(message, isComplete = false) {
    console.log('Adding AI message:', { isComplete, messageLength: message?.length });
    
    const time = getCurrentTime();
    const messageHtml = `
      <div class="chat chat-start chat-ai">
        <div class="chat-image">
          <div class="w-10 h-10 rounded-full bg-gradient-to-br from-cyan-400 via-blue-500 to-purple-600 flex items-center justify-center p-0">
            <i class="fas fa-robot text-white text-sm transform translate-y-[1px]"></i>
          </div>
        </div>
        <div class="chat-header opacity-70 text-xs">
          Wisdomizer <span class="message-time">${time}</span>
        </div>
        <div class="chat-bubble msg-ai bg-gray-700/70 text-gray-100 shadow-md border border-gray-600/30 backdrop-blur-sm">
          ${isComplete ? formatMessage(message) : `
            <div class="typing-indicator" id="typing-indicator">
              <span></span>
              <span></span>
              <span></span>
            </div>
          `}
        </div>
        <div class="chat-footer opacity-70 text-xs">
          ${isComplete ? 'Delivered' : 'Typing...'}
        </div>
      </div>
    `;
    
    messagesContainer.append(messageHtml);
    
    // Apply highlighting and render diagrams
    applyHighlighting();
    
    scrollToBottom();
    
    // Only add animation delay for incomplete messages
    if (!isComplete) {
      setTimeout(() => {
        const aiMessageBubble = $('.chat-ai').last().find('.chat-bubble');
        aiMessageBubble.html(formatMessage(message));
        
        // Apply highlighting after updating content
        applyHighlighting();
        
        scrollToBottom();
      }, 500);
    }
    
    console.log('AI message added:', { isComplete, messageLength: message?.length });
  }
  
  function addWelcomeMessage() {
    console.log('Adding welcome message with mermaid diagram');
    
    const markdownWelcome = `# Welcome to Wisdomizer! 👋

I'm your AI assistant, ready to help with information, explanations, and creative tasks.

## What I can do:

* Answer questions on a wide range of topics
* Generate and explain code in multiple languages
* Help with writing and creative tasks
* Format responses with **bold**, *italic*, and \`code\` styling
* Create diagrams with mermaid syntax

### Code example:

\`\`\`javascript
// A simple function in JavaScript
function greet(name) {
  return \`Hello, \${name}! Welcome to Wisdomizer.\`;
}
\`\`\`

### Diagram example:

\`\`\`mermaid
flowchart TD
    A[Start] --> B{Is it a question?}
    B -->|Yes| C[Research and analyze]
    B -->|No| D[Generate creative content]
    C --> E[Provide answer]
    D --> E
    E --> F[End]
\`\`\`

How can I assist you today?`;

    const time = getCurrentTime();
    const formattedContent = formatMessage(markdownWelcome);
    
    const messageHtml = `
      <div class="chat chat-start">
        <div class="chat-image avatar">
          <div class="w-10 h-10 rounded-full bg-gradient-to-br from-cyan-400 via-blue-500 to-purple-600 flex items-center justify-center">
            <i class="fas fa-robot text-white text-center"></i>
          </div>
        </div>
        <div class="chat-header opacity-70 text-xs">
          Wisdomizer <span class="message-time">${time}</span>
        </div>
        <div class="chat-bubble msg-ai bg-gray-700/70 text-gray-100 shadow-md border border-gray-600/30 backdrop-blur-sm">
          ${formattedContent}
        </div>
        <div class="chat-footer opacity-70 text-xs">
          Delivered
        </div>
      </div>
    `;
    
    messagesContainer.append(messageHtml);
    
    // Give a small delay to ensure DOM insertion before attempting to render diagrams
    setTimeout(() => {
      applyHighlighting();
      processMermaidDiagrams();
      
      // Multiple attempts with increasing delays to ensure diagram rendering
      setTimeout(() => {
        processMermaidDiagrams();
      }, 500);
      
      setTimeout(() => {
        processMermaidDiagrams();
      }, 1500);
    }, 100);
    
    scrollToBottom();
  }
  
  function processUserMessage(message) {
    // Show AI is typing
    addTypingIndicator();
    
    // Prepare API request data
    const requestData = {
      message: message,
      topic: currentTopic,
      chat_uuid: currentChatUUID
    };
    
    // Add file data if available
    if (uploadedFile) {
      const reader = new FileReader();
      reader.onload = function(e) {
        // Add file data to request
        requestData.file = {
          name: uploadedFile.name,
          content: e.target.result.split(',')[1], // Get base64 data without the prefix
          type: uploadedFile.type
        };
        
        // Send to API with file
        sendToApi(requestData);
      };
      reader.readAsDataURL(uploadedFile);
    } else {
      // Send to API without file
      sendToApi(requestData);
    }
  }
  
  function sendToApi(requestData) {
    console.log('Sending to API:', requestData);
    
    // Add system prompt to the request
    requestData.system = systemPrompt;
    
    // If running in development mode, use simulated response
    if (window.location.hostname === 'localhost' && false) {
      simulateStreamResponse(requestData.message);
      return;
    }
    
    // URL will be filled in later - using a dummy URL for now
    const apiUrl = '/chat'; // Use relative path instead of hardcoded URL
    
    // If there's an ongoing stream, abort it
    if (currentStreamController) {
      currentStreamController.abort();
      currentStreamController = null;
    }
    
    // Create new abort controller for this request
    currentStreamController = new AbortController();
    const { signal } = currentStreamController;
    
    // Custom streaming implementation
    streamRequest(apiUrl, requestData, signal);
  }
  
  /**
   * Performs a streaming request to the server
   * @param {string} url - The URL to send the request to
   * @param {object} data - The data to send in the request
   * @param {AbortSignal} signal - AbortController signal for cancellation
   */
  function streamRequest(url, data, signal) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open('POST', url);
      xhr.setRequestHeader('Content-Type', 'application/json');
      xhr.setRequestHeader('Accept', 'text/event-stream');
      xhr.responseType = 'text';
      xhr.timeout = 60000; // 60 seconds timeout
      
      // Set up abort controller
      if (signal) {
        signal.addEventListener('abort', () => {
          xhr.abort();
          reject(new Error('Request aborted'));
        });
      }
      
      let aiMessage = '';
      let isFirstChunk = true;
      
      xhr.onreadystatechange = function() {
        if (xhr.readyState === 3 || xhr.readyState === 4) {
          // Start processing any available data
          readStream();
        }
        
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            // Request completed successfully
            resolve(aiMessage);
          } else {
            // Handle errors
            console.error('Stream request failed:', xhr.status, xhr.statusText);
            reject(new Error(`Request failed with status ${xhr.status}`));
          }
        }
      };
      
      function readStream() {
        let newData = xhr.responseText;
        
        // Split the response by event delimiter and process each event
        const events = newData.split('data: ');
        
        for (let i = 0; i < events.length; i++) {
          const event = events[i].trim();
          if (!event) continue;
          
          try {
            const parsed = JSON.parse(event);
            
            // Check for DONE marker
            if (parsed.content === '|DONE|') {
              // Remove typing indicator if it exists
              removeTypingIndicator();
              
              // Complete message is done, add final message if not already added
              if (aiMessage && isFirstChunk) {
                addAiMessage(aiMessage, true);
                isFirstChunk = false;
              }
              
              continue;
            }
            
            // Handle content chunks
            if (parsed.content) {
              // Remove typing indicator on first content
              if (isFirstChunk) {
                removeTypingIndicator();
                
                // Add initial message
                addAiMessage(parsed.content, false);
                aiMessage = parsed.content;
                isFirstChunk = false;
              } else {
                // Append to existing message
                aiMessage += parsed.content;
                
                // Update message in UI
                updateAiMessage(aiMessage);
              }
            }
          } catch (e) {
            console.error('Error parsing event stream:', e, event);
          }
        }
      }
      
      xhr.send(JSON.stringify(data));
    });
  }
  
  /**
   * For testing only: Simulates a streaming response
   * @param {string} userMessage - The user's message
   */
  function simulateStreamResponse(userMessage) {
    let response = '';
    const totalChunks = 20;
    let chunkIndex = 0;
    
    // Generate a response based on user message
    const baseResponse = getSimulatedResponse(userMessage);
    const chunkSize = Math.ceil(baseResponse.length / totalChunks);
    
    // Simulate streaming with delays
    const streamInterval = setInterval(() => {
      const start = chunkIndex * chunkSize;
      const end = Math.min(start + chunkSize, baseResponse.length);
      
      if (start >= baseResponse.length) {
        clearInterval(streamInterval);
        addAiMessage(response, true);
        return;
      }
      
      // Add the next chunk
      const chunk = baseResponse.substring(start, end);
      response += chunk;
      
      // Update the message
      addAiMessage(response, false);
      
      chunkIndex++;
    }, 100);
  }
  
  /**
   * For testing only: Returns a simulated response
   * @param {string} message - The user's message
   * @returns {string} - A simulated AI response
   */
  function getSimulatedResponse(message) {
    // Simple test responses
    if (message.toLowerCase().includes('hello') || message.toLowerCase().includes('hi')) {
      return "Hello there! 👋 How can I assist you today with Wisdomizer? I'm here to help answer your questions and provide insights on various topics.";
    } else if (message.toLowerCase().includes('help')) {
      return "I'm Wisdomizer, your AI assistant. Here's what I can help you with:\n\n- Answer questions on almost any topic\n- Provide explanations and summaries\n- Assist with brainstorming and creative thinking\n- Help with problem-solving and decision-making\n\nJust type your question or request, and I'll do my best to assist you!";
    } else if (message.toLowerCase().includes('thank')) {
      return "You're welcome! It's my pleasure to help. Is there anything else you'd like to know about?";
    } else if (message.toLowerCase().includes('how are you')) {
      return "As an AI, I don't have feelings, but I'm functioning well and ready to assist you! How can I help you today?";
    } else {
      return `Thanks for your message: "${message}"\n\nI'm a simulated response for testing purposes. In the actual implementation, I would provide a meaningful and helpful response based on your query. Is there anything specific you'd like to know about Wisdomizer?`;
    }
  }
  
  function startNewChat() {
    // Create a new topic with timestamp
    const timestamp = new Date().toLocaleString().replace(/[/:\\]/g, '-');
    const newTopicName = `New Chat ${timestamp}`;
    
    // Make API call to create topic
    fetch('/topics', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        title: newTopicName,
        description: 'New chat topic'
      })
    })
    .then(response => {
      if (!response.ok) {
        throw new Error(`Failed to create topic: ${response.statusText}`);
      }
      return response.json();
    })
    .then(topic => {
      // Add to the topics list
      addTopicToSidebar(topic.title, topic.uuid, true);
      
      // Set as current topic and chat UUID
      currentTopic = topic.title;
      currentChatUUID = topic.uuid;
      
      // Clear the chat and add welcome message
      messagesContainer.empty();
      addWelcomeMessage();
      
      // Close mobile sidebar if open
      mobileSidebar.removeClass('show');
      sidebarBackdrop.removeClass('show');
      
      // Update UI to show active topic
      $('.topic-item').removeClass('bg-gray-700/50').addClass('hover:bg-gray-700/30');
      $('.topic-item').removeClass('text-gray-100').addClass('text-gray-300');
      $(`.topic-item[data-uuid="${topic.uuid}"]`).removeClass('hover:bg-gray-700/30').addClass('bg-gray-700/50');
      $(`.topic-item[data-uuid="${topic.uuid}"]`).removeClass('text-gray-300').addClass('text-gray-100');
      
      console.log('New chat created and loaded:', { topicTitle: topic.title, topicUUID: topic.uuid });
    })
    .catch(error => {
      console.error('Error creating topic:', error);
      createNotification('Failed to create new topic', 'error');
    });
  }
  
  function addTopicToSidebar(topicName, topicUUID, isActive = false) {
    const topicHtml = `
      <div class="topic-item flex items-center gap-2 p-2 rounded-lg ${isActive ? 'bg-gray-700/50 text-gray-100' : 'hover:bg-gray-700/30 text-gray-300'} cursor-pointer group" data-uuid="${topicUUID}">
        <i class="fas fa-comment-alt text-xs ${isActive ? 'text-gray-400' : 'text-gray-500'}"></i>
        <span class="topic-name truncate flex-grow text-sm">${topicName}</span>
        <div class="topic-actions ${window.innerWidth >= 768 ? 'opacity-0 group-hover:opacity-100 transition-opacity' : ''} flex gap-1">
          <button class="topic-rename p-1 text-gray-400 hover:text-gray-200"><i class="fas fa-pencil-alt text-xs"></i></button>
          <button class="topic-delete p-1 text-gray-400 hover:text-gray-200"><i class="fas fa-trash-alt text-xs"></i></button>
        </div>
      </div>
    `;
    
    // Add to both desktop and mobile sidebars
    $('#topics-sidebar .overflow-y-auto').prepend(topicHtml);
    $('#mobile-topics-sidebar .overflow-y-auto').prepend(topicHtml);
  }
  
  function loadTopic(topicName, topicUUID) {
    console.log('Loading topic:', { topicName, topicUUID });
    
    // Generate a unique ID for this topic loading operation
    const loadingId = Date.now().toString();
    currentTopicLoadingId = loadingId;
    
    // Update state variables
    currentTopic = topicName;
    currentChatUUID = topicUUID;
    
    // Stop any ongoing message streaming
    if (currentStreamController) {
      currentStreamController.abort();
      currentStreamController = null;
    }
    
    // Clear the existing messages
    messagesContainer.empty();
    
    // Show loading state
    const loadingHtml = `
      <div id="loading-indicator" class="flex justify-center items-center h-full">
        <div class="text-gray-400">
          <i class="fas fa-spinner fa-spin mr-2"></i>
          Loading chat history...
        </div>
      </div>
    `;
    messagesContainer.html(loadingHtml);
    
    // Fetch chat history
    console.log('Fetching chat history from:', `/chat/${topicUUID}`);
    return fetch(`/chat/${topicUUID}`)
      .then(response => {
        // If another topic has started loading, abort this one
        if (currentTopicLoadingId !== loadingId) {
          console.log('Aborting topic load - newer load in progress');
          return Promise.reject(new Error('Topic load aborted'));
        }
        
        console.log('Chat history response status:', response.status);
        if (!response.ok) {
          throw new Error(`Failed to load chat history: ${response.statusText}`);
        }
        return response.json();
      })
      .then(data => {
        // If another topic has started loading, abort this one
        if (currentTopicLoadingId !== loadingId) {
          console.log('Aborting topic processing - newer load in progress');
          return Promise.reject(new Error('Topic load aborted'));
        }
        
        console.log('Received chat history data:', {
          chat: data.chat,
          messageCount: data.messages?.length || 0
        });
        
        // Clear everything in the messages container
        messagesContainer.empty();
        
        // Add each message from history
        if (data.messages && data.messages.length > 0) {
          console.log('Adding messages to chat:', data.messages.length);
          let processedCount = 0;
          
          // Process messages sequentially with a delay to ensure proper rendering
          const processMessage = (index) => {
            // If another topic has started loading, abort this one
            if (currentTopicLoadingId !== loadingId) {
              console.log('Aborting message processing - newer load in progress');
              return;
            }
            
            if (index >= data.messages.length) {
              // All messages processed, add topic change message
              const messageHtml = `
                <div class="flex justify-center my-4">
                  <div class="bg-gray-800/70 text-gray-400 text-xs py-1 px-3 rounded-full border border-gray-700/50">
                    Switched to topic: ${topicName}
                  </div>
                </div>
              `;
              messagesContainer.append(messageHtml);
              applyHighlighting();
              scrollToBottom();
              
              // Final verification
              setTimeout(() => {
                if (currentTopicLoadingId !== loadingId) return;
                
                const renderedMessages = messagesContainer.find('.chat').length;
                console.log('Final message count verification:', {
                  expected: data.messages.length,
                  rendered: renderedMessages,
                  difference: data.messages.length - renderedMessages,
                  processedCount
                });
              }, 500);
              
              return;
            }
            
            const msg = data.messages[index];
            console.log(`Processing message ${index + 1}/${data.messages.length}:`, { 
              role: msg.role, 
              contentLength: msg.content?.length
            });
            
            if (msg.role === 'user') {
              addUserMessage(msg.content);
              lastUserMessage = msg.content;
              processedCount++;
            } else if (msg.role === 'assistant') {
              addAiMessage(msg.content, true);
              processedCount++;
            } else {
              console.warn(`Unknown message role: ${msg.role}`);
            }
            
            // Process next message after a short delay
            setTimeout(() => processMessage(index + 1), 50);
          };
          
          // Start processing messages
          processMessage(0);
        } else {
          console.log('No messages found in chat history');
          addWelcomeMessage();
        }
        
        console.log('Chat history loaded successfully');
      })
      .catch(error => {
        // If this is an intentional abort, don't show an error
        if (error.message === 'Topic load aborted') {
          console.log('Topic load was intentionally aborted');
          return;
        }
        
        // Only handle the error if this is still the current loading operation
        if (currentTopicLoadingId === loadingId) {
          console.error('Error loading chat history:', error);
          messagesContainer.empty();
          addWelcomeMessage();
          createNotification('Failed to load chat history', 'error');
        }
        
        throw error;
      });
  }
  
  function renameTopic(topicUUID, newName) {
    fetch(`/topics/${topicUUID}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        title: newName
      })
    })
    .then(response => {
      if (!response.ok) {
        throw new Error(`Failed to rename topic: ${response.statusText}`);
      }
      return response.json();
    })
    .then(topic => {
      // Update the topic name in the UI
      $(`.topic-item[data-uuid="${topicUUID}"] .topic-name`).text(topic.title);
      
      if (currentTopic === topic.title) {
        currentTopic = topic.title;
      }
      
      createNotification(`Topic renamed to "${topic.title}"`, 'success');
    })
    .catch(error => {
      console.error('Error renaming topic:', error);
      createNotification('Failed to rename topic', 'error');
    });
  }
  
  function deleteTopic(topicUUID) {
    console.log('Deleting topic:', topicUUID);
    
    // First, clear the chat if this is the current topic
    if (currentChatUUID === topicUUID) {
      messagesContainer.empty();
      addWelcomeMessage();
      
      // Reset state variables
      currentTopic = "Getting started with Wisdomizer";
      currentChatUUID = null;
      lastUserMessage = "";
    }
    
    // Remove the topic from the UI immediately
    $(`.topic-item[data-uuid="${topicUUID}"]`).remove();
    
    // Make API call to delete topic
    fetch(`/topics/${topicUUID}`, {
      method: 'DELETE'
    })
    .then(response => {
      console.log('Delete topic response status:', response.status);
      if (!response.ok) {
        throw new Error(`Failed to delete topic: ${response.statusText}`);
      }
      return response.json();
    })
    .then(() => {
      console.log('Topic deleted successfully');
      
      // If this was the current topic, start a new chat
      if (currentChatUUID === topicUUID) {
        // Start a new chat after a short delay to ensure UI is updated
        setTimeout(() => {
          startNewChat();
        }, 100);
      }
      
      createNotification('Topic deleted', 'info');
    })
    .catch(error => {
      console.error('Error deleting topic:', error);
      console.error('Error details:', {
        message: error.message,
        stack: error.stack,
        topicUUID
      });
      
      // Restore the topic in UI if deletion failed
      if (currentChatUUID === topicUUID) {
        currentTopic = "Getting started with Wisdomizer";
        currentChatUUID = null;
        lastUserMessage = "";
        startNewChat();
      }
      
      createNotification('Failed to delete topic', 'error');
    });
  }
  
  function showFilePreview(file) {
    const fileSizeStr = formatFileSize(file.size);
    const filePreviewHtml = `
      <div class="file-preview bg-gray-700/30 p-2 max-w-[300px]">
        <div class="flex items-center gap-2">
          <i class="fas fa-file ${getFileIcon(file.type)} text-blue-400"></i>
          <span class="file-name text-sm truncate flex-1">${file.name}</span>
          <span class="file-size text-xs opacity-70">${fileSizeStr}</span>
          <div class="file-remove text-gray-300 hover:text-white">
            <i class="fas fa-times text-xs"></i>
          </div>
        </div>
      </div>
    `;
    
    filePreviewContainer.html(filePreviewHtml).removeClass('hidden');
    
    // Add click handler for removing file
    $('.file-remove').on('click', function() {
      uploadedFile = null;
      filePreviewContainer.addClass('hidden');
      fileUpload.val('');
    });
  }
  
  // Helper functions
  function formatMessage(message) {
    // Process markdown with XSS protection
    try {
      // Check if markdown libraries are available
      if (typeof marked === 'undefined' || typeof DOMPurify === 'undefined') {
        throw new Error('Markdown libraries not available');
      }
      
      // Simple detection of mermaid code blocks
      const hasMermaidBlock = message.includes('```mermaid') || 
                             message.includes('~~~mermaid');
      
      if (hasMermaidBlock) {
        // Log details about detected Mermaid blocks for debugging
        console.log('Detected Mermaid code block in message');
        
        // Find all Mermaid code blocks for debugging
        const mermaidRegex = /```mermaid\n([\s\S]*?)```|~~~mermaid\n([\s\S]*?)~~~/g;
        let match;
        while ((match = mermaidRegex.exec(message)) !== null) {
          const content = match[1] || match[2];
          console.log('Found Mermaid block with content:', content);
        }
      }
      
      let preprocessedMessage = message;
      
      // If it has mermaid content, decode HTML entities
      if (hasMermaidBlock) {
        console.log('Preprocessing message with HTML entities');
        
        // Simple entity decoding for known issues
        preprocessedMessage = message
          .replace(/--&gt;/g, '-->')
          .replace(/&lt;/g, '<')
          .replace(/&gt;/g, '>')
          .replace(/&quot;/g, '"')
          .replace(/&#39;/g, "'")
          .replace(/&amp;/g, '&');
      }
      
      // Don't escape HTML for mermaid diagrams
      let contentToProcess;
      
      if (hasMermaidBlock) {
        // For content with mermaid, skip HTML escaping
        contentToProcess = preprocessedMessage;
      } else {
        // For normal content without mermaid, continue with HTML escaping
        contentToProcess = escapeHtml(preprocessedMessage);
      }
      
      // Render the markdown
      const rawHtml = marked.parse(contentToProcess);
      
      if (hasMermaidBlock) {
        // Check if Mermaid diagrams were properly generated
        console.log('Checking generated Mermaid HTML');
        
        if (rawHtml.includes('class="mermaid"')) {
          console.log('Mermaid divs found in output HTML');
        } else {
          console.warn('No Mermaid divs found in output HTML');
        }
      }
      
      // Sanitize the HTML to prevent XSS attacks
      const cleanHtml = DOMPurify.sanitize(rawHtml, {
        USE_PROFILES: { html: true },
        ADD_ATTR: ['target', 'data-processed', 'data-source'],
        ALLOWED_TAGS: [
          'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 
          'p', 'br', 'hr', 'ol', 'ul', 'li', 
          'blockquote', 'pre', 'code', 'span', 'div',
          'strong', 'em', 'a', 'table', 'thead', 
          'tbody', 'tr', 'th', 'td', 'img', 'details', 
          'summary', 'del', 'input', 'svg', 'g', 'path',
          'circle', 'rect', 'polygon', 'ellipse', 'line',
          'polyline', 'text', 'foreignObject', 'marker'
        ],
        ALLOWED_ATTR: [
          'href', 'src', 'alt', 'class', 'style', 'type', 'checked',
          'data-processed', 'data-source', 'id', 'viewBox', 'd', 'fill',
          'stroke', 'stroke-width', 'x', 'y', 'cx', 'cy', 'r', 'width', 
          'height', 'transform', 'points', 'marker-end', 'marker-start',
          'text-anchor', 'font-family', 'font-size', 'dominant-baseline'
        ],
        ADD_TAGS: ['mermaid'],
        ALLOWED_CLASSES: {
          'div': ['mermaid', 'markdown-content']
        }
      });
      
      // Add markdown class for styling
      return `<div class="markdown-content">${cleanHtml}</div>`;
    } catch (error) {
      console.error('Error formatting message:', error);
      
      // Fallback to basic formatting
      return message
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/\n/g, '<br>')
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        .replace(/`(.*?)`/g, '<code>$1</code>');
    }
  }
  
  // Escape HTML to prevent XSS before markdown processing
  function escapeHtml(text) {
    return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }
  
  function scrollToBottom() {
    messagesContainer[0].scrollTo({
      top: messagesContainer[0].scrollHeight,
      behavior: 'smooth'
    });
  }
  
  function getCurrentTime() {
    const now = new Date();
    let hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const ampm = hours >= 12 ? 'PM' : 'AM';
    hours = hours % 12;
    hours = hours ? hours : 12; // the hour '0' should be '12'
    return `${hours}:${minutes} ${ampm}`;
  }
  
  function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
    else if (bytes < 1073741824) return (bytes / 1048576).toFixed(1) + ' MB';
    else return (bytes / 1073741824).toFixed(1) + ' GB';
  }
  
  function getFileIcon(fileType) {
    if (fileType.startsWith('image/')) return 'fa-image';
    if (fileType.startsWith('video/')) return 'fa-video';
    if (fileType.startsWith('audio/')) return 'fa-music';
    if (fileType === 'application/pdf') return 'fa-file-pdf';
    if (fileType.includes('word')) return 'fa-file-word';
    if (fileType.includes('excel') || fileType.includes('spreadsheet')) return 'fa-file-excel';
    if (fileType.includes('powerpoint') || fileType.includes('presentation')) return 'fa-file-powerpoint';
    if (fileType.includes('zip') || fileType.includes('compressed')) return 'fa-file-archive';
    if (fileType.includes('text/')) return 'fa-file-alt';
    if (fileType.includes('code') || fileType.includes('javascript') || fileType.includes('json')) return 'fa-file-code';
    return 'fa-file';
  }
  
  // Add typing indicator for AI
  function addTypingIndicator() {
    isAiResponding = true;
    const time = getCurrentTime();
    const indicatorHtml = `
      <div class="chat chat-start ai-thinking" id="typing-indicator">
        <div class="chat-image">
          <div class="w-10 h-10 rounded-full bg-gradient-to-br from-cyan-400 via-blue-500 to-purple-600 flex items-center justify-center p-0">
            <i class="fas fa-robot text-white text-sm transform translate-y-[1px]"></i>
          </div>
        </div>
        <div class="chat-header opacity-70 text-xs">
          Wisdomizer <span class="message-time">${time}</span>
        </div>
        <div class="chat-bubble msg-ai bg-gray-700/70 text-gray-100 shadow-md border border-gray-600/30 backdrop-blur-sm p-4">
          <div class="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
        </div>
        <div class="chat-footer opacity-70 text-xs">
          Typing...
        </div>
      </div>
    `;
    
    messagesContainer.append(indicatorHtml);
    applyHighlighting();
    scrollToBottom();
  }
  
  // Remove typing indicator
  function removeTypingIndicator() {
    $('#typing-indicator').remove();
    isAiResponding = false;
  }
  
  // Update existing AI message
  function updateAiMessage(content) {
    const aiMessageElement = $('.chat-ai').last();
    if (aiMessageElement.length) {
      aiMessageElement.find('.chat-bubble').html(formatMessage(content));
      
      // Apply highlighting
      applyHighlighting();
      
      scrollToBottom();
    }
  }
  
  // Function to process all unprocessed mermaid diagrams on the page
  function processMermaidDiagrams() {
    // Check if mermaid is loaded
    if (typeof mermaid === 'undefined') {
      console.error('Mermaid library not loaded.');
      return;
    }

    // Find all unprocessed mermaid divs
    const unprocessedDiagrams = Array.from(document.querySelectorAll('div.mermaid:not([data-processed="true"])'));
    console.log(`Found ${unprocessedDiagrams.length} unprocessed mermaid diagrams.`);
    
    // If no diagrams to process, add retry buttons to any that might be stuck
    if (unprocessedDiagrams.length === 0) {
      setTimeout(addRetryButtonsToStuckDiagrams, 1000);
      return;
    }

    // Process each diagram
    unprocessedDiagrams.forEach((diagram) => {
      // Generate a unique ID if not already set
      if (!diagram.id) {
        diagram.id = `mermaid-diagram-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
      }

      // Get the content - clean up any HTML entities in the content
      let content = diagram.textContent.trim();
      
      // Skip empty diagrams
      if (!content) {
        console.warn(`Empty diagram content in ${diagram.id}`);
        return;
      }
      
      // Store original content in data attribute for later reference
      // This is critical for retry functionality
      diagram.setAttribute('data-content', content);
      
      console.log(`Processing diagram ${diagram.id} with content: ${content.substring(0, 30)}...`);
      
      // Show loading indicator
      showLoadingIndicator(diagram);
      
      // Use our isolated rendering process
      renderMermaidSafely(content, diagram.id)
        .then(svg => {
          // Hide loading indicator
          hideLoadingIndicator(diagram);
          
          // Set the SVG content
          diagram.innerHTML = svg;
          diagram.setAttribute('data-processed', 'true');
          console.log(`Successfully processed diagram ${diagram.id}`);
        })
        .catch(error => {
          // Hide loading indicator
          hideLoadingIndicator(diagram);
          
          console.error(`Failed to process diagram ${diagram.id}:`, error);
          displayMermaidError(diagram, error, content);
        });
    });

    // Add retry buttons to any diagrams that might be stuck
    setTimeout(addRetryButtonsToStuckDiagrams, 3000);
  }
  
  // Helper function to show a loading indicator
  function showLoadingIndicator(diagram) {
    // Clear the diagram content first to avoid mixing with loading indicator
    const originalContent = diagram.innerHTML;
    diagram.setAttribute('data-original-content', originalContent);
    
    // Create a fresh loading indicator
    diagram.classList.add('mermaid-loading');
    
    // Create a completely separate loading container
    const loadingContainer = document.createElement('div');
    loadingContainer.className = 'mermaid-loading-container';
    loadingContainer.innerHTML = '<div class="mermaid-loading-indicator">Processing diagram...</div>';
    
    // Clear existing content and add loading indicator
    diagram.innerHTML = '';
    diagram.appendChild(loadingContainer);
  }
  
  // Helper function to hide loading indicator
  function hideLoadingIndicator(diagram) {
    diagram.classList.remove('mermaid-loading');
    
    // Remove any loading containers
    const loadingContainers = diagram.querySelectorAll('.mermaid-loading-container');
    loadingContainers.forEach(container => container.remove());
  }
  
  // Render Mermaid diagram with complete isolation
  function renderMermaidSafely(content, id) {
    return new Promise((resolve, reject) => {
      try {
        // Generate a unique ID for this render operation
        const uniqueId = `render-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
        
        // Create a temporary, hidden div for rendering
        const renderDiv = document.createElement('div');
        renderDiv.id = uniqueId;
        renderDiv.style.position = 'absolute';
        renderDiv.style.visibility = 'hidden';
        renderDiv.style.pointerEvents = 'none';
        renderDiv.style.width = '1px';
        renderDiv.style.height = '1px';
        renderDiv.style.overflow = 'hidden';
        renderDiv.style.top = '-9999px';
        renderDiv.style.left = '-9999px';
        
        // Add to document but outside normal flow
        document.body.appendChild(renderDiv);
        
        // Create a direct string with the content
        const contentString = content.trim();
        
        // Log attempt for debugging
        console.log(`Attempting to render with ID ${uniqueId}`);
        
        // Use a timeout to let the DOM settle
        setTimeout(() => {
          try {
            // Directly call mermaid.render with the content string
            mermaid.render(uniqueId, contentString)
              .then(result => {
                // Extract the SVG
                const svg = result.svg;
                
                // Clean up
                if (document.body.contains(renderDiv)) {
                  document.body.removeChild(renderDiv);
                }
                
                // Resolve with the SVG
                resolve(svg);
              })
              .catch(renderError => {
                console.error(`Direct rendering error:`, renderError);
                
                // Clean up
                if (document.body.contains(renderDiv)) {
                  document.body.removeChild(renderDiv);
                }
                
                // Try a simple fallback if this was a parsing error
                if (renderError.toString().includes('Parse error') || 
                    renderError.toString().includes('Syntax error')) {
                  
                  console.log('Attempting fallback simple diagram');
                  const fallbackContent = 'flowchart TD\n    A[Content] --> B[Could not be rendered]';
                  
                  // Create a new render div for the fallback
                  const fallbackDiv = document.createElement('div');
                  const fallbackId = `fallback-${Date.now()}`;
                  fallbackDiv.id = fallbackId;
                  fallbackDiv.style.position = 'absolute';
                  fallbackDiv.style.visibility = 'hidden';
                  fallbackDiv.style.top = '-9999px';
                  document.body.appendChild(fallbackDiv);
                  
                  // Try rendering the fallback
                  mermaid.render(fallbackId, fallbackContent)
                    .then(fallbackResult => {
                      const fallbackSvg = fallbackResult.svg;
                      
                      // Clean up
                      if (document.body.contains(fallbackDiv)) {
                        document.body.removeChild(fallbackDiv);
                      }
                      
                      resolve(fallbackSvg);
                    })
                    .catch(fallbackError => {
                      console.error('Even fallback diagram failed:', fallbackError);
                      
                      // Clean up
                      if (document.body.contains(fallbackDiv)) {
                        document.body.removeChild(fallbackDiv);
                      }
                      
                      reject(renderError); // Return the original error
                    });
                } else {
                  // Not a parsing error, just reject
                  reject(renderError);
                }
              });
          } catch (setupError) {
            console.error('Setup error during render:', setupError);
            
            // Clean up
            if (document.body.contains(renderDiv)) {
              document.body.removeChild(renderDiv);
            }
            
            reject(setupError);
          }
        }, 50);
      } catch (error) {
        console.error('Critical render setup error:', error);
        reject(error);
      }
    });
  }
  
  // Function to display a Mermaid error with more details
  function displayMermaidError(diagram, error, content) {
    console.error('Mermaid error:', error);
    
    // Remove loading class if present
    diagram.classList.remove('mermaid-loading');
    
    // Create error container
    const errorContainer = document.createElement('div');
    errorContainer.className = 'mermaid-error';
    errorContainer.style.padding = '10px';
    errorContainer.style.border = '1px solid #fed7d7';
    errorContainer.style.borderRadius = '4px';
    errorContainer.style.backgroundColor = '#fff5f5';
    errorContainer.style.color = '#c53030';
    errorContainer.style.fontFamily = 'monospace';
    errorContainer.style.margin = '10px 0';
    
    // Create error header
    const errorHeader = document.createElement('div');
    errorHeader.style.fontWeight = 'bold';
    errorHeader.style.marginBottom = '8px';
    errorHeader.textContent = 'Diagram Rendering Error';
    errorContainer.appendChild(errorHeader);
    
    // Parse and add the error message
    let errorMessage = error.toString();
    
    // Special handling for parse errors
    if (errorMessage.includes('Parse error') || errorMessage.includes('Syntax error')) {
      const match = errorMessage.match(/Parse error on line (\d+)/);
      if (match && match[1] && content) {
        const lineNumber = parseInt(match[1]);
        errorMessage = `Syntax error on line ${lineNumber}`;
        
        // Show the problematic line of code with some context
        const lines = content.split('\n');
        if (lines.length >= lineNumber) {
          const errorLineElement = document.createElement('pre');
          errorLineElement.style.margin = '8px 0';
          errorLineElement.style.padding = '8px';
          errorLineElement.style.backgroundColor = '#2d3748';
          errorLineElement.style.color = '#e2e8f0';
          errorLineElement.style.borderRadius = '4px';
          errorLineElement.style.overflowX = 'auto';
          
          // Add line context (few lines before and after)
          const startLine = Math.max(0, lineNumber - 3);
          const endLine = Math.min(lines.length, lineNumber + 2);
          
          for (let i = startLine; i < endLine; i++) {
            const lineNumStr = `${i + 1}`.padStart(3, ' ');
            const lineContent = lines[i] || '';
            const isErrorLine = i + 1 === lineNumber;
            
            if (isErrorLine) {
              errorLineElement.innerHTML += `<span style="color: #f56565; font-weight: bold">${lineNumStr}: ${escapeHtml(lineContent)}</span>\n`;
            } else {
              errorLineElement.innerHTML += `<span style="color: #a0aec0">${lineNumStr}: ${escapeHtml(lineContent)}</span>\n`;
            }
          }
          
          errorContainer.appendChild(errorLineElement);
        }
        
        // Add helpful hint
        const hintElement = document.createElement('div');
        hintElement.style.marginTop = '8px';
        hintElement.style.fontSize = '0.9em';
        hintElement.innerHTML = `
          <strong>Hints:</strong>
          <ul style="margin-top: 4px; padding-left: 20px;">
            <li>Check syntax on line ${lineNumber}</li>
            <li>Make sure diagram starts with diagram type (flowchart TD, sequenceDiagram, etc.)</li>
            <li>Verify all nodes and connections have proper syntax</li>
          </ul>
        `;
        errorContainer.appendChild(hintElement);
      }
    }
    // Display general error if not a parse error
    else {
      const messageElement = document.createElement('div');
      messageElement.textContent = errorMessage;
      errorContainer.appendChild(messageElement);
    }
    
    // Set the error content
    diagram.innerHTML = '';
    diagram.appendChild(errorContainer);
    
    // Add retry button
    const retryButton = document.createElement('button');
    retryButton.className = 'mermaid-retry-button';
    retryButton.textContent = 'Retry Diagram';
    retryButton.style.display = 'block';
    retryButton.style.margin = '10px auto';
    retryButton.style.padding = '5px 10px';
    retryButton.style.backgroundColor = '#4f46e5';
    retryButton.style.color = 'white';
    retryButton.style.border = 'none';
    retryButton.style.borderRadius = '4px';
    retryButton.style.cursor = 'pointer';
    
    retryButton.addEventListener('click', function() {
      retryRenderDiagram(diagram);
    });
    
    diagram.appendChild(retryButton);
  }
  
  // Apply syntax highlighting to code blocks and process mermaid diagrams
  function applyHighlighting() {
    try {
      // Apply syntax highlighting
      if (typeof hljs !== 'undefined') {
        document.querySelectorAll('pre code:not(.mermaid)').forEach((block) => {
          hljs.highlightElement(block);
        });
      }
      
      // Process mermaid diagrams
      processMermaidDiagrams();
    } catch (e) {
      console.error('Error applying syntax highlighting:', e);
    }
  }
  
  // Add mermaid error styles
  function addMermaidErrorStyles() {
    const style = document.createElement('style');
    style.textContent = `
      .syntax-error-in-text {
        background-color: rgba(255, 50, 50, 0.2);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid rgba(255, 50, 50, 0.5);
        margin-top: 10px;
        font-family: monospace;
        white-space: pre-wrap;
        font-size: 14px;
        color: #ffcccc;
      }
      
      .mermaid-error {
        background-color: rgba(255, 50, 50, 0.2);
        padding: 10px;
        border-radius: 5px;
        border: 1px solid rgba(255, 50, 50, 0.5);
        margin-top: 10px;
        font-family: monospace;
        white-space: pre-wrap;
        font-size: 14px;
        color: #ffcccc;
      }
    `;
    document.head.appendChild(style);
  }
  
  // Force rendering of all mermaid diagrams using direct approach with mermaid API
  function forceMermaidRendering() {
    console.log('Force rendering all mermaid diagrams');
    
    if (typeof mermaid === 'undefined') {
      console.error('Mermaid library not loaded');
      return;
    }
    
    try {
      // Find ALL mermaid divs regardless of processed status
      const allDiagrams = document.querySelectorAll('div.mermaid');
      console.log(`Total mermaid divs: ${allDiagrams.length}`);
      
      // If no diagrams found, try to find potential missed markdown code blocks
      if (allDiagrams.length === 0) {
        // Look for code blocks that might contain mermaid syntax
        const codeBlocks = document.querySelectorAll('pre code');
        const potentialMermaidBlocks = Array.from(codeBlocks).filter(block => {
          const content = block.textContent || '';
          return content.includes('graph ') || 
                 content.includes('flowchart ') || 
                 content.includes('sequenceDiagram') ||
                 content.includes('classDiagram') ||
                 content.includes('stateDiagram') ||
                 content.includes('gantt') ||
                 content.includes('pie') ||
                 content.includes('gitGraph');
        });
        
        if (potentialMermaidBlocks.length > 0) {
          console.log(`Found ${potentialMermaidBlocks.length} potential mermaid code blocks that weren't detected`);
          
          potentialMermaidBlocks.forEach((block, index) => {
            try {
              // Get the parent element (pre tag)
              const pre = block.parentElement;
              if (!pre) return;
              
              // Create a new mermaid div
              const mermaidDiv = document.createElement('div');
              mermaidDiv.className = 'mermaid';
              mermaidDiv.id = `mermaid-converted-${Date.now()}-${index}`;
              mermaidDiv.textContent = block.textContent;
              
              // Replace the pre with the mermaid div
              pre.parentNode.replaceChild(mermaidDiv, pre);
              
              // Now render this new div
              const content = mermaidDiv.textContent.trim();
              if (!content) {
                console.warn(`Converted diagram #${index+1} has no content to render`);
                mermaidDiv.innerHTML = '<div class="mermaid-error">Empty diagram content</div>';
                return;
              }
              
              // Add loading indicator
              mermaidDiv.classList.add('mermaid-loading');
              mermaidDiv.innerHTML = '<div class="mermaid-loading-indicator">Rendering diagram...</div>';
              
              mermaid.render(`render-${mermaidDiv.id}`, content)
                .then(result => {
                  mermaidDiv.classList.remove('mermaid-loading');
                  mermaidDiv.innerHTML = result.svg;
                  mermaidDiv.setAttribute('data-processed', 'true');
                  console.log(`Successfully converted and rendered code block as diagram #${index + 1}`);
                })
                .catch(err => {
                  mermaidDiv.classList.remove('mermaid-loading');
                  console.error(`Failed to render converted code block #${index + 1}:`, err);
                  // Display error in the mermaid div
                  displayMermaidError(mermaidDiv, err, content);
                });
            } catch (err) {
              console.error(`Error converting code block #${index + 1} to mermaid:`, err);
            }
          });
        }
        
        console.log('No explicit mermaid divs found');
        return;
      }
      
      // Process all diagrams, including those marked as processed
      allDiagrams.forEach((diagram, index) => {
        try {
          // Generate a unique ID if missing
          if (!diagram.id) {
            diagram.id = `mermaid-force-${Date.now()}-${index}`;
          }
          
          // Clear the processed attribute to force re-rendering
          diagram.removeAttribute('data-processed');
          
          // Get content and clean it
          const content = diagram.textContent.trim();
          if (!content) {
            console.warn(`Diagram #${index + 1} has no content to render`);
            displayMermaidError(diagram, new Error("Empty diagram content"), "");
            return;
          }
          
          console.log(`Force rendering diagram #${index + 1} with content: ${content.substring(0, 30)}...`);
          
          // Store the content for rendering
          diagram.setAttribute('data-content', content);
          
          // Preserve the original content before adding loading indicator
          const contentBackup = diagram.textContent;
          
          // Add loading indicator
          diagram.classList.add('mermaid-loading');
          diagram.innerHTML = '<div class="mermaid-loading-indicator">Rendering diagram...</div>';
          
          // Direct rendering approach using render API
          mermaid.render(`render-${diagram.id}`, content)
            .then(result => {
              // Remove loading class
              diagram.classList.remove('mermaid-loading');
              
              // Replace the content with rendered SVG
              diagram.innerHTML = result.svg;
              diagram.setAttribute('data-processed', 'true');
              console.log(`Successfully force rendered diagram #${index + 1}`);
            })
            .catch(err => {
              // Remove loading class
              diagram.classList.remove('mermaid-loading');
              
              console.error(`Failed to force render diagram #${index + 1}:`, err);
              
              // Restore original content
              diagram.textContent = contentBackup;
              
              displayMermaidError(diagram, err, content);
            });
        } catch (err) {
          // Remove loading class if it exists
          if (diagram) {
            diagram.classList.remove('mermaid-loading');
            console.error(`Error force processing diagram #${index + 1}:`, err);
            displayMermaidError(diagram, err, diagram.textContent);
          } else {
            console.error(`Error with null diagram in force rendering:`, err);
          }
        }
      });
    } catch (err) {
      console.error('Error in forceMermaidRendering:', err);
    }
  }
  
  // Function to add retry buttons to stuck diagrams
  function addRetryButtonsToStuckDiagrams() {
    console.log('Checking for stuck diagrams...');

    const allDiagrams = document.querySelectorAll('div.mermaid');
    let stuckDiagrams = 0;

    allDiagrams.forEach(diagram => {
      // Check if this diagram is still loading or has an error message
      const isStuck = diagram.classList.contains('mermaid-loading') || 
                      (diagram.querySelector('.mermaid-error') !== null);
      
      // Check if the diagram has a retry button already
      const hasRetryButton = diagram.querySelector('.mermaid-retry-button') !== null;
      
      if (isStuck && !hasRetryButton) {
        stuckDiagrams++;
        console.log(`Found stuck diagram: ${diagram.id}`);
        
        // Create retry button
        const retryButton = document.createElement('button');
        retryButton.className = 'mermaid-retry-button';
        retryButton.textContent = 'Retry Rendering';
        retryButton.style.display = 'block';
        retryButton.style.margin = '10px auto';
        retryButton.style.padding = '5px 10px';
        retryButton.style.backgroundColor = '#4f46e5';
        retryButton.style.color = 'white';
        retryButton.style.border = 'none';
        retryButton.style.borderRadius = '4px';
        retryButton.style.cursor = 'pointer';
        
        // Add click event to retry the rendering
        retryButton.addEventListener('click', function() {
          retryRenderDiagram(diagram);
        });
        
        // Add the button to the diagram
        diagram.appendChild(retryButton);
      }
    });
    
    if (stuckDiagrams > 0) {
      console.log(`Added retry buttons to ${stuckDiagrams} stuck diagrams`);
    } else {
      console.log('No stuck diagrams found');
    }
  }
  
  // Function to retry rendering a specific diagram
  function retryRenderDiagram(diagram) {
    if (!diagram || typeof mermaid === 'undefined') return;
    
    try {
      console.log(`Retrying diagram rendering for ${diagram.id}`);
      
      // Get content from data attributes ONLY - never from DOM elements
      let content = null;
      
      // Try data-content first
      if (diagram.hasAttribute('data-content')) {
        content = diagram.getAttribute('data-content');
        console.log('Found content in data-content attribute');
      }
      // Try data-source next
      else if (diagram.hasAttribute('data-source')) {
        try {
          content = decodeURIComponent(diagram.getAttribute('data-source'));
          console.log('Found and decoded content from data-source attribute');
        } catch (e) {
          console.error("Error decoding source:", e);
        }
      }
      
      // If no content found from data attributes, use a fallback diagram
      if (!content || content.trim() === '') {
        console.warn('No content found in data attributes, using fallback diagram');
        content = 'flowchart TD\n    A[Content Missing] --> B[Please try again]';
      }
      
      // Trim and clean the content
      content = content.trim();
      console.log(`Diagram content to render: ${content.substring(0, 30)}...`);
      
      // Show a loading indicator
      showLoadingIndicator(diagram);
      
      // Use completely isolated rendering
      renderMermaidSafely(content, diagram.id)
        .then(svg => {
          // Hide loading indicator
          hideLoadingIndicator(diagram);
          
          // Set the SVG content
          diagram.innerHTML = svg;
          diagram.setAttribute('data-processed', 'true');
          console.log('Successfully rendered diagram');
        })
        .catch(error => {
          // Hide loading indicator
          hideLoadingIndicator(diagram);
          
          console.error('Failed to render diagram:', error);
          displayMermaidError(diagram, error, content);
        });
    } catch (error) {
      console.error('Error in retry rendering:', error);
      hideLoadingIndicator(diagram);
      displayMermaidError(diagram, error, 'Error setting up rendering');
    }
  }
});
